# Leocode Recruitment Task

## Requirements
- **Node** v16
- **yarn** as pacakge manager


## API Documentation
App includes swagger documentation avialable after start in `/documentation` path
You can also take a look at autogenerated JSON schema  in [./openapi.json](./openapi.json)

See more in [JSON Schema / Open API](#json-schema--open-api) section

## Seeded users
App seed some users during startup (see [./src/main.ts](./src/main.ts)).

| Email | Password |
| --- | --- |
| user1@app.dev | S0m3P@ssw0rd |
| user2@app.dev | S0m3P@ssw0rd2 |

## What's bundled

### TypeScript

Entire project is written using TypeScript 4. No JS files should be necessary.

### ESLint / Prettier

[Eslint](https://eslint.org) and [Prettier](https://prettier.io) are configured in the project using predefinied [@hypedevs/eslint-config](https://github.com/hypedevs/eslint-config) library. You can adjust them to your liking by modifying the `eslint` section in `package.json`.

### Fastify

[Fastify](https://fastify.io) is the core framework used for HTTP in this project.

### JSON Schema / Open API / JSON API

As Fastify [supports JSON Schema out of the box](https://www.fastify.io/docs/v2.2.x/Validation-and-Serialization/) each request is described in as much detail as possible. Check out `*.ctrl.ts` files to see how to endpoint are provided with dedicated OpenAPI definition.

After any change in routes JSON Schema definition with api started up, the [./openapi.json](./openapi.json) file will be reconstructed, transforming and combining JSON Schemas from controllers into a single JSON. It's commited to the repo and serve as reference for current API interface.

#### Swagger
Server provide [swagger](https://swagger.io/) panel for documentation browsing: http://localhost:3000/documentation

#### FastifyTypedRoute
A util library that allows type inference from JSON Schemas directly into route handler is present in this project. I built this library some time ago but didn't publish it yet cause it miss tests - the plan is to make it public when I have time - currently it's available in the [lib/fastify-typed-route](./lib/fastifty-typed-route) directory if you want to get git log for this one I can also share access to repository with you.

## Conventions

#### File naming
- in [src](./src/), all files should be named with either `strictCamelCase` or `StrictPascalCase`(only class modules and decorators)
- in [lib](./lib/), all files should be named with `kebab-case`. The difference versus `src` is deliberate and not only enforces the distinction between these two directories purposes, but also prepares these small packages for proper functioning with npm and potential of being extracted to a separate module.

#### Syntax naming
- variables and constants scoped in a single module - `strictCamelCase`
- exported constants - `UPPER_CASE`
- enums, enum members - `UPPER_CASE`
- functions - `strictCamelCase`
- decorators - `StrictPascalCase`
- classes, interfaces, type aliases - `StrictPascalCase`
- generic type parameters - `PascalCase`

### Dependency injection

Throughout the codebase, many uses of dependency injection can be found. They are done by currying the dependencies in the top level function,
followed by function logic arguments placed in the returned callback.

```ts

// declare function with DI as const
const getKeyPairForEmail =
  // introduce dependencies in top level function
  ({ keysStorage, log }: { keysStorage: InternalKeysStorage, log: FastifyLoggerInstance }) =>
  // introduce logic arguments in the returned function
  async ({ email }: { email: string }) => {
    const privKey = keysStorage.getPrivateKey(email)?.value;
    const pubKey = keysStorage.getPublicKey(email)?.value;

    if (!privKey || !pubKey) {
      log.fatal('Missing rsa key pair for user', { user: { email } });
      throw new Error('Missing key pair for user');
    }

    return { privKey, pubKey };
  };
```

In most cases, only a single level of currying is required. This allows reuse of these functions in the same scope.